name: ServerScriptService
type: class
memory_category: Instances
summary: |
  A container service for server-only `Class.Script` objects.
description: |
  **ServerScriptService** is a container service for `Class.Script`,
  `Class.ModuleScript` and other scripting-related assets that are only meant
  for server use. The contents are never replicated to player clients at all,
  which allows for a secure storage of important game logic. Script objects will
  run if they are within this service and not
  `Class.BaseScript.Disabled|Disabled`.

  This service houses just one property,
  `Class.ServerScriptService.LoadStringEnabled|LoadStringEnabled`, which
  determines whether the `loadstring` function in Luau is enabled. It's
  recommended to keep this disabled for security reasons, as misusing this
  function can lead to remote code execution vulnerabilities.

  Scripts running in ServerScriptService may need access to various other assets
  which are not scripting-related, such as prefabricated models to be
  `Class.Instance:Clone()|cloned`. Such assets should go in
  `Class.ServerStorage`, which behaves similarly to this service except that
  `Class.Script` objects will not run even if they are not
  `Class.BaseScript.Disabled|Disabled`. Assets and `Class.ModuleScript` that are
  useful to both the server and clients should go in `Class.ReplicatedStorage`
  instead. Finally, you can further organize objects within this service through
  the use of `Class.Folder|Folders` without affecting the way it behaves.
code_samples: []
inherits:
  - Instance
tags:
  - NotCreatable
  - Service
  - NotReplicated
deprecation_message: ''
properties:
  - name: ServerScriptService.LoadStringEnabled
    summary: |
      Toggles whether or not the `loadstring` function can be used by server
      scripts. Defaults to false.
    description: |
      Toggles whether or not the `loadstring` function can be used by server
      scripts. Defaults to false.
    code_samples: []
    type: boolean
    tags:
      - NotReplicated
      - NotScriptable
    deprecation_message: ''
    security:
      read: None
      write: None
    thread_safety: ReadSafe
    category: Behavior
    serialization:
      can_load: true
      can_save: true
    capabilities: []
    writeCapabilities: []
methods: []
events: []
-- Double Jump Script
-- Place in a LocalScript in StarterPlayerScripts

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local userInputService = game:GetService("UserInputService")

-- Double jump variables
local hasDoubleJumped = false
local canDoubleJump = false
local doubleJumpForce = 60

-- Function to perform double jump
local function doubleJump()
    if canDoubleJump and not hasDoubleJumped then
        hasDoubleJumped = true
        
        -- Apply upward force
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            -- Stop any downward velocity first
            rootPart.Velocity = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z)
            -- Then apply upward force
            rootPart.Velocity = Vector3.new(rootPart.Velocity.X, doubleJumpForce, rootPart.Velocity.Z)
            
            -- Optional: Add a particle effect for the double jump
            local jumpEffect = Instance.new("ParticleEmitter")
            jumpEffect.Texture = "rbxassetid://6101261295" -- Cloud particle
            jumpEffect.Size = NumberSequence.new(1.5)
            jumpEffect.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.5),
                NumberSequenceKeypoint.new(1, 1)
            })
            jumpEffect.Lifetime = NumberRange.new(0.3, 0.5)
            jumpEffect.Speed = NumberRange.new(5, 10)
            jumpEffect.Acceleration = Vector3.new(0, -10, 0)
            jumpEffect.SpreadAngle = Vector2.new(50, 50)
            jumpEffect.Rate = 50
            jumpEffect.Parent = rootPart
            
            -- Remove the effect after a short time
            game:GetService("Debris"):AddItem(jumpEffect, 0.3)
            
            print("Double jumped!")
        end
    end
end

-- Track jumping and landing states
humanoid.StateChanged:Connect(function(oldState, newState)
    if newState == Enum.HumanoidStateType.Jumping then
        canDoubleJump = true
    elseif newState == Enum.HumanoidStateType.Landed then
        canDoubleJump = false
        hasDoubleJumped = false
    end
end)

-- Listen for jump input (Space key)
userInputService.JumpRequest:Connect(function()
    if canDoubleJump and not hasDoubleJumped then
        -- The player is already in the air (first jump has occurred)
        -- Wait a tiny delay so this doesn't trigger immediately with the regular jump
        task.delay(0.1, doubleJump)
    end
end)

-- Handle character respawning
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    hasDoubleJumped = false
    canDoubleJump = false
    
    -- Re-connect the state change event
    humanoid.StateChanged:Connect(function(oldState, newState)
        if newState == Enum.HumanoidStateType.Jumping then
            canDoubleJump = true
        elseif newState == Enum.HumanoidStateType.Landed then
            canDoubleJump = false
            hasDoubleJumped = false
        end
    end)
end)

print("Double jump script loaded! Jump twice to use.")
